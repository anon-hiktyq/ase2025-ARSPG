FUNCTION INITIALIZATION
========================================

type_name:__Delay
初始待处理函数: ['DelayFun']

GENERATE ANNOTATION FOR DelayFun
========================================

函数 DelayFun 已经初始化
开始生成 DelayFun 的注释代码
文件 3_output/test_ip/DelayFun.c 已成功创建并写入。
文件 1_output/test_ip/DelayFun.c 已成功创建并写入。
文件 2_output/test_ip/DelayFun.c 已成功创建并写入。

GENERATE LOOP INVARIANT FOR DelayFun
========================================

Loop 0 : Outer
Sorted indices: [0]
LoopEntry_0:
(t == 0) * (pIp == pIp@pre) * (pIp@pre->delaytime == pIp_delaytime)
Successfully generated loop/DelayFun.json
{'pIp@pre->delaytime_length', 'pIp_length', 'pIp_v', 't_length', 'pIp@pre->delaytime_v', 't_v'}
Variable Maps: [{'t': '0', 'pIp': 'pIp@pre', 'pIp@pre->delaytime': 'pIp_delaytime'}]
Path conditions: [None]
Pre condition: (t == 0) * (pIp == pIp@pre) * (pIp@pre->delaytime == pIp_delaytime)
Loop Condition: t<pIp -> delaytime
Array Names: []
Updated Loop Conditions: ['0<pIp@pre -> delaytime']
Global Unchanged Variables ['pIp', 'pIp@pre->delaytime']
Non Inductive Variables []

FUNCTION INITIALIZATION
========================================

type_name:__Delay
初始待处理函数: ['DelayFun']

GENERATE ANNOTATION FOR DelayFun
========================================

函数 DelayFun 已经初始化
开始生成 DelayFun 的注释代码
文件 3_output/test_ip/DelayFun.c 已成功创建并写入。
文件 1_output/test_ip/DelayFun.c 已成功创建并写入。
文件 2_output/test_ip/DelayFun.c 已成功创建并写入。

GENERATE LOOP INVARIANT FOR DelayFun
========================================

Loop 0 : Outer
Sorted indices: [0]
LoopEntry_0:
(t == 0) * (pIp == pIp@pre) * (pIp@pre->delaytime == pIp_delaytime)
Successfully generated loop/DelayFun.json
{'pIp@pre->delaytime_v', 'pIp@pre->delaytime_length', 'pIp_v', 't_length', 'pIp_length', 't_v'}
Variable Maps: [{'t': '0', 'pIp': 'pIp@pre', 'pIp@pre->delaytime': 'pIp_delaytime'}]
Path conditions: [None]
Pre condition: (t == 0) * (pIp == pIp@pre) * (pIp@pre->delaytime == pIp_delaytime)
Loop Condition: t<pIp -> delaytime
Array Names: []
Updated Loop Conditions: ['0<pIp@pre -> delaytime']
Global Unchanged Variables ['pIp', 'pIp@pre->delaytime']
Non Inductive Variables []
syntax Correct
Validate:
[True, True, True, True, True]

Verify:
[]

syntax Correct
Validate:
[True, True, True, True, True]

Verify:
[]

ACSL 格式的循环不变量
/*@
      loop invariant (0 < \at(pIp,Pre)->delaytime) ==> (t <= \at(pIp,Pre)->delaytime);
      loop invariant (0 < \at(pIp,Pre)->delaytime) ==> (t >= 0);
      loop invariant (!(0 < \at(pIp,Pre)->delaytime)) ==> ((t == 0) && (pIp == \at(pIp,Pre)) && (\at(pIp,Pre)->delaytime == \at(pIp->delaytime,Pre)));
      loop invariant pIp == \at(pIp,Pre);
      loop invariant \at(pIp,Pre)->delaytime == \at(pIp->delaytime,Pre);
    */
    for (; t < pIp->delaytime; t++)
    {
        ;
    }
VST 格式的循环不变量
/*@ Inv
    ((0 < pIp@pre->delaytime) => (t <= pIp@pre->delaytime)) &&
((0 < pIp@pre->delaytime) => (t >= 0)) &&
((!(0 < pIp@pre->delaytime)) => ((t == 0) && (pIp == pIp@pre) && (pIp@pre->delaytime == pIp->delaytime@pre))) &&
(pIp == pIp@pre) &&
(pIp@pre->delaytime == pIp->delaytime@pre)
    */
    
    for (; t < pIp->delaytime; t++)
    {
        ;
    }
PARTIAL CORRECT INVARIANT
继续符号执行
/*@ Inv
    ((0 < pIp@pre->delaytime) => (t <= pIp@pre->delaytime)) &&
((0 < pIp@pre->delaytime) => (t >= 0)) &&
((!(0 < pIp@pre->delaytime)) => ((t == 0) && (pIp == pIp@pre) && (pIp@pre->delaytime == pIp->delaytime@pre))) &&
(pIp == pIp@pre) &&
(pIp@pre->delaytime == pIp->delaytime@pre)
    */
    
    for (; t < pIp->delaytime; t++)
    {
        ;
    }
LoopEntry_0:
(t == 0) * (pIp == pIp@pre) * (pIp@pre->delaytime == pIp_delaytime)
Successfully generated loop/DelayFun.json
syntax Correct
Validate:
[True, True, True, True, True]

Verify:
[]

CORRECT INVARIANT

GENERATE FUNCTION SUMMARY FOR DelayFun
========================================

----------------------------------------
路径约束与返回值
Combined path condition:
(exists t_58, t_58 >= pIp_delaytime && (0 < pIp_delaytime => t_58 <= pIp_delaytime) && (0 < pIp_delaytime => t_58 >= 0) && (!(0 < pIp_delaytime) => t_58 == 0 && pIp == pIp && pIp_delaytime == pIp_delaytime) && pIp->delaytime == pIp_delaytime)
----------------------------------------

开始生成完整的 DelayFun 的注释代码
文件 2_output/test_ip/DelayFun.c 已成功创建并写入。
开始生成 DelayFun 的 ACSL 规约
Variable Map: {'pIp->delaytime': 'pIp_delaytime'}
Path Condition: exists delaytime t_58, t_58 >= pIp_delaytime && (0 < pIp_delaytime => t_58 <= pIp_delaytime) && (0 < pIp_delaytime => t_58 >= 0) && (!(0 < pIp_delaytime) => t_58 == 0 && pIp == pIp && pIp_delaytime == pIp_delaytime) 
Result: None
文件 output/test_ip/DelayFun.c 已成功创建并写入。

SUMMARY FOR DelayFun
========================================


函数 DelayFun 的 VST Summary 为:
/*@
With pIp_delaytime
Require pIp->delaytime == pIp_delaytime
Ensure (exists t_58, t_58 >= pIp_delaytime && (0 < pIp_delaytime => t_58 <= pIp_delaytime) && (0 < pIp_delaytime => t_58 >= 0) && (!(0 < pIp_delaytime) => t_58 == 0 && pIp == pIp && pIp_delaytime == pIp_delaytime) && pIp->delaytime == pIp_delaytime)
*/

函数 DelayFun 的 ACSL Summary 为:
/*@
 requires \valid(pIp) ;

ensures \exists int delaytime, t_58;  t_58 >= \old(pIp->delaytime) && (0 < \old(pIp->delaytime) ==> t_58 <= \old(pIp->delaytime)) && (0 < \old(pIp->delaytime) ==> t_58 >= 0) && (!(0 < \old(pIp->delaytime)) ==> t_58 == 0 && pIp == pIp && \old(pIp->delaytime) == \old(pIp->delaytime)) ==> pIp->delaytime == \old(pIp->delaytime);

*/


VERIFICATION FOR DelayFun
========================================

syntax Correct
Loop Invariant:
[True, True, True, True, True]

Assertion:
[]

Post Condition:
[True]

